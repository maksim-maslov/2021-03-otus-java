##### Задача:
Написать приложение, которое следит за сборками мусора и пишет в лог количество сборок каждого типа(young, old) и время которое ушло на сборки в минуту.
Добиться OutOfMemory в этом приложении через медленное подтекание по памяти (например, добавлять элементы в List и удалять только половину).
Настроить приложение так чтобы оно падало с OOM примерно через 5 минут после начала работы.
Собрать статистику (количество сборок, время на сборки) по разным GC.
Сделать выводы: Какой gc лучше и почему?

##### Выводы:
Приложение запускалось с тремя типами сборщиков мусора: SerialGC, ParallelGC и G1GC (3 запуска на каждом сборщике).
Объём памяти выделенный под область heap: 256 и 2048 mb.
Результаты запусков в таблице ниже.

|                    | Количество малых сборок | Количество больших сборок | Общее время на сборки | Время работы приложения |
|--------------------|-------------------------|---------------------------|-----------------------|-------------------------|
| SerialGC - 256m    | 15                      | 76                        | 13079-14814ms         | 333-348ms               |
| ParallelGC - 256m  | 26                      | 48-61                     | 6097-7130ms           | 286-287ms               |
| G1GC - 256m        | 75-79                   | 35-38                     | 6303-7761ms           | 339-354ms               |
| SerialGC - 2048m   | 16                      | 67-85                     | 92379-111016ms        | 344-413ms               |
| ParallelGC - 2048m | 26                      | 53-55                     | 40163-50064ms         | 275-295ms               |
| G1GC - 2048m       | 102-109                 | 48-56                     | 52977-70243ms         | 334-382ms               |


По замерам из таблицы меньшее время на сборку мусора уходит при запусках с ParallelGC, 6097 и 40163 мс. При этом время работы приложения менее 5 минут, по логам работы видно что объём heap ~1880mb, при работе с G1GC - ~2040mb. В логах хип дампа на момент падения приложения размер тестового ArrayList ~1750 элементов, с G1GC - 2050 элементов. Причина в разнице в настройках JVM, по умолчанию для ParallelGC часть памяти около 150 mb отводится под область Survivor space.

На дефолтных настройках лучше отрабатывает G1GC. При запусках с этим типом, по сравнению c ParallelGC, приложение полностью использует выделенный heap (выполняет больше вставок и удалений в ArrayList), по сравнению с SerialGC - меньше времени уходит на сборку мусора и простой приложения.