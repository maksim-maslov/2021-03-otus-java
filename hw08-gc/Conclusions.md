##### Задача:
Написать приложение, которое следит за сборками мусора и пишет в лог количество сборок каждого типа(young, old) и время которое ушло на сборки в минуту.
Добиться OutOfMemory в этом приложении через медленное подтекание по памяти
(например, добавлять элементы в List и удалять только половину).
Настроить приложение (можно добавлять Thread.sleep(...)) так чтобы оно падало
с OOM примерно через 5 минут после начала работы.
Собрать статистику (количество сборок, время на сборки) по разным GC.
Сделать выводы: Какой gc лучше и почему?

##### Выводы:
Приложение запускалось с тремя типами сборщиков мусора: SerialGC, ParallelGC и G1GC (по 3 раза на каждом сборщике).
Объём памяти выделенный под область heap: 256 и 2048 mb.
Результаты запусков в таблице ниже.

|                    | Количество малых сборок | Количество больших сборок | Общее время на сборки | Время работы приложения |
|--------------------|-------------------------|---------------------------|-----------------------|-------------------------|
| SerialGC - 256m    | 15                      | 76                        | 13079-14814ms         | 333-348ms               |
| ParallelGC - 256m  | 26                      | 48-61                     | 6097-7130ms           | 286-287ms               |
| G1GC - 256m        | 75-79                   | 35-38                     | 6303-7761ms           | 339-354ms               |
| SerialGC - 2048m   | 16                      | 67-85                     | 92379-111016ms        | 344-413ms               |
| ParallelGC - 2048m | 26                      | 53-55                     | 40163-50064ms         | 275-295ms               |
| G1GC - 2048m       | 102-109                 | 48-56                     | 52977-70243ms         | 334-382ms               |

Лучше всего приложение отработало при сборщике G1GC.
При этом типе большие сборки запускались реже чем при SerialGC и ParallelGC, поэтому меньше ушло времени на сборку мусора и простой приложения.